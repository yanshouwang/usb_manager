// Autogenerated from Pigeon (v9.2.4), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

/// A class representing a USB accessory, which is an external hardware component that communicates with an android
/// application over USB. The accessory is the USB host and android the device side of the USB connection.
class UsbAccessory {
  UsbAccessory({
    required this.manufacturer,
    required this.model,
    this.description,
    this.version,
    this.uri,
    this.serial,
  });

  String manufacturer;

  String model;

  String? description;

  String? version;

  String? uri;

  String? serial;

  Object encode() {
    return <Object?>[
      manufacturer,
      model,
      description,
      version,
      uri,
      serial,
    ];
  }

  static UsbAccessory decode(Object result) {
    result as List<Object?>;
    return UsbAccessory(
      manufacturer: result[0]! as String,
      model: result[1]! as String,
      description: result[2] as String?,
      version: result[3] as String?,
      uri: result[4] as String?,
      serial: result[5] as String?,
    );
  }
}

class UsbDevice {
  UsbDevice({
    required this.deviceClass,
    required this.deviceSubclass,
    required this.deviceProtocol,
    required this.deviceName,
    required this.vendorId,
    required this.productId,
    this.manufacturerName,
    this.productName,
    required this.configurationCount,
    required this.interfaceCount,
    required this.version,
  });

  int deviceClass;

  int deviceSubclass;

  int deviceProtocol;

  String deviceName;

  int vendorId;

  int productId;

  String? manufacturerName;

  String? productName;

  int configurationCount;

  int interfaceCount;

  String version;

  Object encode() {
    return <Object?>[
      deviceClass,
      deviceSubclass,
      deviceProtocol,
      deviceName,
      vendorId,
      productId,
      manufacturerName,
      productName,
      configurationCount,
      interfaceCount,
      version,
    ];
  }

  static UsbDevice decode(Object result) {
    result as List<Object?>;
    return UsbDevice(
      deviceClass: result[0]! as int,
      deviceSubclass: result[1]! as int,
      deviceProtocol: result[2]! as int,
      deviceName: result[3]! as String,
      vendorId: result[4]! as int,
      productId: result[5]! as int,
      manufacturerName: result[6] as String?,
      productName: result[7] as String?,
      configurationCount: result[8]! as int,
      interfaceCount: result[9]! as int,
      version: result[10]! as String,
    );
  }
}

class UsbConfiguration {
  UsbConfiguration({
    required this.id,
    this.name,
    required this.maxPower,
    required this.interfaceCount,
    required this.isRemoteWakeup,
    required this.isSelfPowered,
  });

  int id;

  String? name;

  int maxPower;

  int interfaceCount;

  bool isRemoteWakeup;

  bool isSelfPowered;

  Object encode() {
    return <Object?>[
      id,
      name,
      maxPower,
      interfaceCount,
      isRemoteWakeup,
      isSelfPowered,
    ];
  }

  static UsbConfiguration decode(Object result) {
    result as List<Object?>;
    return UsbConfiguration(
      id: result[0]! as int,
      name: result[1] as String?,
      maxPower: result[2]! as int,
      interfaceCount: result[3]! as int,
      isRemoteWakeup: result[4]! as bool,
      isSelfPowered: result[5]! as bool,
    );
  }
}

class UsbInterface {
  UsbInterface({
    required this.id,
    required this.alternateSetting,
    required this.interfaceClass,
    required this.interfaceSubclass,
    required this.interfaceProtocol,
    this.name,
    required this.endpointCount,
  });

  int id;

  int alternateSetting;

  int interfaceClass;

  int interfaceSubclass;

  int interfaceProtocol;

  String? name;

  int endpointCount;

  Object encode() {
    return <Object?>[
      id,
      alternateSetting,
      interfaceClass,
      interfaceSubclass,
      interfaceProtocol,
      name,
      endpointCount,
    ];
  }

  static UsbInterface decode(Object result) {
    result as List<Object?>;
    return UsbInterface(
      id: result[0]! as int,
      alternateSetting: result[1]! as int,
      interfaceClass: result[2]! as int,
      interfaceSubclass: result[3]! as int,
      interfaceProtocol: result[4]! as int,
      name: result[5] as String?,
      endpointCount: result[6]! as int,
    );
  }
}

class _UsbManagerHostApiCodec extends StandardMessageCodec {
  const _UsbManagerHostApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is UsbAccessory) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is UsbDevice) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return UsbAccessory.decode(readValue(buffer)!);
      case 129: 
        return UsbDevice.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

/// This class allows you to access the state of USB and communicate with USB devices. Currently only host mode is
/// supported in the public API.
class UsbManagerHostApi {
  /// Constructor for [UsbManagerHostApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  UsbManagerHostApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _UsbManagerHostApiCodec();

  /// Returns a list of currently attached USB accessories. (in the current implementation there can be at most one)
  ///
  /// Requires the PackageManager#FEATURE_USB_ACCESSORY feature which can be detected using
  /// PackageManager.hasSystemFeature(String).
  Future<List<UsbAccessory?>> getAccessoryList() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.UsbManagerHostApi.getAccessoryList', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as List<Object?>?)!.cast<UsbAccessory?>();
    }
  }

  /// Returns a HashMap containing all USB devices currently attached. USB device name is the key for the returned
  /// HashMap. The result will be empty if no devices are attached, or if USB host mode is inactive or unsupported.
  ///
  /// Requires the PackageManager#FEATURE_USB_HOST feature which can be detected using
  /// PackageManager.hasSystemFeature(String).
  Future<Map<String?, UsbDevice?>> getDeviceList() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.UsbManagerHostApi.getDeviceList', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as Map<Object?, Object?>?)!.cast<String?, UsbDevice?>();
    }
  }

  /// Returns true if the caller has permission to access the accessory. Permission might have been granted temporarily via
  /// requestPermission(android.hardware.usb.UsbAccessory, android.app.PendingIntent) or by the user
  /// choosing the caller as the default application for the accessory.
  ///
  /// Requires the PackageManager#FEATURE_USB_ACCESSORY feature which can be detected using
  /// PackageManager.hasSystemFeature(String).
  Future<bool> hasAccessoryPermission(UsbAccessory arg_accessory) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.UsbManagerHostApi.hasAccessoryPermission', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_accessory]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }

  /// Returns true if the caller has permission to access the device. Permission might have been granted temporarily via
  /// requestPermission(android.hardware.usb.UsbDevice, android.app.PendingIntent) or by the user
  /// choosing the caller as the default application for the device. Permission for USB devices of class
  /// UsbConstants#USB_CLASS_VIDEO for clients that target SDK Build.VERSION_CODES.P and above can be granted
  /// only if they have additionally the Manifest.permission.CAMERA permission.
  ///
  /// Requires the PackageManager#FEATURE_USB_HOST feature which can be detected using
  /// PackageManager.hasSystemFeature(String).
  Future<bool> hasDevicePermission(UsbDevice arg_device) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.UsbManagerHostApi.hasDevicePermission', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_device]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }
}

class _UsbDeviceHostApiCodec extends StandardMessageCodec {
  const _UsbDeviceHostApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is UsbConfiguration) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is UsbInterface) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return UsbConfiguration.decode(readValue(buffer)!);
      case 129: 
        return UsbInterface.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

/// This class represents a USB device attached to the android device with the android device acting as the USB host. Each
/// device contains one or more UsbInterfaces, each of which contains a number of UsbEndpoints (the channels via
/// which data is transmitted over USB).
///
/// This class contains information (along with UsbInterface and UsbEndpoint) that describes the capabilities of the
/// USB device. To communicate with the device, you open a UsbDeviceConnection for the device and use UsbRequest
/// to send and receive data on an endpoint. UsbDeviceConnection#controlTransfer is used for control requests on
/// endpoint zero.
class UsbDeviceHostApi {
  /// Constructor for [UsbDeviceHostApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  UsbDeviceHostApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _UsbDeviceHostApiCodec();

  Future<String?> getSerialNumber(String arg_deviceName) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.UsbDeviceHostApi.getSerialNumber', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_deviceName]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return (replyList[0] as String?);
    }
  }

  /// Returns the UsbConfiguration at the given index.
  Future<UsbConfiguration> getConfiguration(String arg_deviceName, int arg_index) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.UsbDeviceHostApi.getConfiguration', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_deviceName, arg_index]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as UsbConfiguration?)!;
    }
  }

  /// Returns the UsbInterface at the given index. For devices with multiple configurations, you will probably want to use
  /// UsbConfiguration#getInterface instead.
  Future<UsbInterface> getInterface(String arg_deviceName, int arg_index) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.UsbDeviceHostApi.getInterface', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_deviceName, arg_index]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as UsbInterface?)!;
    }
  }
}

class _UsbConfigurationHostApiCodec extends StandardMessageCodec {
  const _UsbConfigurationHostApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is UsbInterface) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return UsbInterface.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

/// A class representing a configuration on a UsbDevice. A USB configuration can have one or more interfaces, each one
/// providing a different piece of functionality, separate from the other interfaces. An interface will have one or more
/// UsbEndpoints, which are the channels by which the host transfers data with the device.
class UsbConfigurationHostApi {
  /// Constructor for [UsbConfigurationHostApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  UsbConfigurationHostApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _UsbConfigurationHostApiCodec();

  /// Returns the UsbInterface at the given index.
  Future<UsbInterface> getInterface(String arg_deviceName, int arg_configurationIndex, int arg_index) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.UsbConfigurationHostApi.getInterface', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_deviceName, arg_configurationIndex, arg_index]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as UsbInterface?)!;
    }
  }
}
